<?php

use Drupal\quiz\Quiz;

/**
 * @file
 * Quiz Module
 *
 * This module allows the creation of interactive quizzes for site visitors.
 */
// This module is structured as follows:
//
// The main module file:
// * Defines and general includes are at the top.
// * Public functions come next.
// * Private functions are at the bottom.
//
// Where possible, user pages are located in quiz.pages.inc, and admin pages
// are in quiz.admin.inc. Most utility functions have been left here, even if they
// are only used by a function in one of the other files. quiz_datetime.inc holds
// some additional date/time functions.
//
// Themes are in quiz.pages.inc unless they clearly only apply to admin screens.
// Then they are in quiz.admin.inc.
//
// Views support is included in includes/views/quiz.views.inc
define('QUIZ_VIEWS_DIR', drupal_get_path('module', 'quiz') . '/includes/views');

/**
 * Include hook implementations.
 */
require_once dirname(__FILE__) . '/quiz.hooks.inc';

module_load_include('inc', 'quiz', 'quiz_datetime');
require_once dirname(__FILE__) . '/quiz.internal.inc';

/*
 * Define question statuses...
 */
define('QUESTION_RANDOM', 0);
define('QUESTION_ALWAYS', 1);
define('QUESTION_NEVER', 2);

/**
 * Quiz name.
 */
define('QUIZ_NAME', _quiz_get_quiz_name());

/**
 * Define options for keeping results.
 */
define('QUIZ_KEEP_BEST', 0);
define('QUIZ_KEEP_LATEST', 1);
define('QUIZ_KEEP_ALL', 2);

/**
 * Factory to create quiz helper.
 *
 * @staticvar Quiz $quiz
 * @param string $className
 * @return \Drupal\quiz\Quiz
 */
function quiz($className = 'Drupal\quiz\Quiz') {
  static $quiz = null;

  if (!$quiz) {
    $quiz = new $className;
  }

  return $quiz;
}

/**
 * Helper function to determine if a user has access to the different results
 * pages.
 *
 * @param $quiz
 *   The quiz node.
 * @param $result_id
 *   The result id of a result we are trying to access.
 * @return boolean
 *   TRUE if user has permission.
 */
function quiz_access_results($quiz, $result_id = NULL) {
  global $user;
  return quiz()->getQuizHelper()->getAccessHelper()->canAccessResults($user, $quiz, $result_id);
}

/**
 * Helper function to determine if a user has access to view his quiz results
 *
 * @param object $quiz
 *  The Quiz node
 */
function quiz_access_my_results($quiz) {
  global $user;
  return quiz()->getQuizHelper()->getAccessHelper()->canAccessMyResults($quiz, $user);
}

/**
 * Helper function to determine if a user has access to view a specific quiz result.
 *
 * @param int $result_id
 *  Result id
 * @return boolean
 *  True if access, false otherwise
 */
function quiz_access_my_result($result_id) {
  return quiz()->getQuizHelper()->getResultHelper()->isResultCompleted($result_id);
}

/**
 * Helper function to determine if a user has access to score a quiz.
 *
 * @param $quiz_creator
 *   uid of the quiz creator.
 */
function quiz_access_to_score($quiz_creator = NULL) {
  global $user;
  return quiz()->getQuizHelper()->getAccessHelper()->canAccessQuizScore($user, $quiz_creator);
}

/**
 * Helper function to check if the user has any of a given list of permissions.
 *
 * @param args
 *   Any number of permissions.
 * @return
 *   TRUE if the user has access to any of the arguments given.
 */
function quiz_access_multi_or() {
  $perms = func_get_args();
  foreach ($perms as $perm) {
    if (user_access($perm)) {
      return TRUE;
    }
  }
}

/**
 * Quiz node form submit callback.
 *
 * @see quiz_form_quiz_node_form_alter()
 */
function quiz_form_quiz_node_form_submit($form, &$form_state) {
  $node = $form_state['node'];

  if (empty($form_state['values']['nid'])) {
    drupal_set_message(t('You just created a new quiz. Now you have to add questions to it. This page is for adding and managing questions. Here you can create new questions or add some of your already created questions. If you want to change the quiz settings, you can use the "edit" tab.'));
    $form_state['redirect'] = "node/$node->nid/quiz/questions";
  }
  // If the quiz don't have any questions jump to the manage questions tab.
  $res = db_query('SELECT child_vid FROM {quiz_node_relationship} WHERE parent_vid = :vid', array(':vid' => $node->vid))->fetchField();
  if (!is_numeric($res)) {
    $form_state['redirect'] = 'node/' . $node->nid . '/quiz/questions';
  }
}

function quiz_update_defaults($node) {
  return quiz()->getQuizHelper()->getSettingHelper()->updateUserDefaultSettings($node);
}

/**
 * Insert or update the quiz node properties accordingly.
 */
function quiz_save_properties($entity) {
  return quiz()->getQuizHelper()->getSettingHelper()->saveQuizSettings($entity);
}

/**
 * Returns default values for all quiz settings.
 *
 * @todo also store this in the quiz_node_properties table
 *
 * @return
 *   Array of default values.
 */
function _quiz_get_node_defaults() {
  return quiz()->getQuizHelper()->getSettingHelper()->getNodeDefaultSettings();
}

/**
 * Result_id, menu argument loader.
 */
function quiz_rid_load($result_id) {
  if ($result_id > 0) {
    return $result_id;
  }

  return FALSE;
}

/**
 * Workaround for a _menu_translate() bug.
 */
function quiz_rid_to_arg() {
  return 0;
}

/**
 * Menu loader callback. Load a quiz node if the given node ID is a quiz.
 */
function quiz_menu_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }
  $node = node_load($nid);
  if (!isset($node->type) || $node->type != 'quiz') {
    return FALSE;
  }
  return $node;
}

/**
 * Helper function for hook_view().
 *
 * Returns a button to use as a link to start taking the quiz.
 *
 * @param $form_state
 *   Form state array.
 * @param $node
 *   The quiz node.
 * @return
 *   Form with a button linking to the take tab.
 */
function quiz_start_quiz_button_form($form, &$form_state, $node) {
  $form = array();
  $form['#action'] = url("node/$node->nid/take");
  $form['button'] = array(
    '#type' => 'submit',
    '#value' => t('Start quiz'),
  );
  return $form;
}

/**
 * Primary quiz-taking view on 'Take' tab.
 */
function quiz_take($node) {
  if (isset($node->rendered_content)) {
    return $node->rendered_content;
  }
  $to_be_rendered = quiz_take_quiz($node);
  return drupal_render($to_be_rendered);
}

/**
 * Does the current user have access to take the quiz?
 *
 * @param $node
 *  The quiz node
 */
function quiz_take_access($node) {
  if ($node->type != 'quiz') {
    return FALSE;
  }
  return node_access('view', $node) && user_access('access quiz') && quiz_availability($node) === TRUE;
}

function _quiz_userpoints_type() {
  $userpoints_terms = taxonomy_get_tree(userpoints_get_vid());
  $userpoints_tids = array(0 => t('Select'));
  foreach ($userpoints_terms as $userpoints_term) {
    $userpoints_tids[$userpoints_term->tid] = str_repeat('-', $userpoints_term->depth) . $userpoints_term->name;
  }
  return $userpoints_tids;
}
 * @defgroup quiz_public Public API functions.
 * @{
 */

/**
 * Validate that a node is of type quiz, and that the user has access to it.
 *
 * @param $node
 * @param $op
 * @return unknown_type
 */
function quiz_type_confirm($node, $op = NULL) {
  if ($node->type != 'quiz') {
    return FALSE;
  }
  if (isset($op)) {
    $node_ops = array('view', 'update', 'delete', 'create');
    if (in_array($op, $node_ops)) {
      return node_access($op, $node);
    }
    return user_access($op);
  }

  return user_access('access quiz');
}

/**
 * Returns the titles for all quizzes the user has access to.
 *
 * @return quizzes
 *   Array with nids as keys and titles as values.
 */
function quiz_get_all_titles() {
  return quiz()->getAllTitles();
}

/**
 * Returns the titles for all quizzes the user has access to.
 *
 * @return quizzes
 *   Array with nids as keys and (array with vid as key and title as value) as values.
 *   Like this: array($nid => array($vid => $title))
 */
function quiz_get_all_version_titles() {
  return quiz()->getAllRevisionTitles();
}

/**
 * Return highest score data for given quizzes.
 *
 * @param $nids
 *   nids for the quizzes we want to collect scores from.
 * @param $uid
 *   uid for the user we want to collect score for.
 * @param $include_num_questions
 *   Do we want to collect information about the number of questions in a quiz?
 *   This adds a performance hit.
 * @return
 *   Array of score data.
 *   For several takes on the same quiz, only returns highest score.
 */
function quiz_get_score_data($nids, $uid, $include_num_questions = FALSE) {
  return quiz()->getQuizHelper()->getScoreData($nids, $uid, $include_num_questions);
}

/**
 * Finds out the number of questions for the quiz.
 *
 * Good example of usage could be to calculate the % of score.
 *
 * @param $nid
 *   Quiz ID.
 * @return
 *   Returns the number of quiz questions.
 */
function quiz_get_number_of_questions($vid) {
  return quiz()->getQuizHelper()->countQuestion($vid);
}

/**
 * Copies quiz-question relation entries in the quiz_node_relationship table
 * from an old version of a quiz to a new.
 *
 * @param $old_quiz_vid
 *   The quiz vid prior to a new revision.
 * @param $new_quiz_vid
 *   The quiz vid of the latest revision.
 * @param $quiz_nid
 *   The quiz node id.
 */
function quiz_update_quiz_question_relationship($old_quiz_vid, $new_quiz_vid, $quiz_nid) {
  // query for questions in previous version
  $result = db_select('quiz_node_relationship', 'qnr')
    ->fields('qnr', array('parent_nid', 'child_nid', 'child_vid', 'question_status', 'weight', 'max_score', 'auto_update_max_score', 'qnr_id', 'qnr_pid'))
    ->condition('parent_nid', $quiz_nid)
    ->condition('parent_vid', $old_quiz_vid)
    ->condition('question_status', QUESTION_NEVER, '!=')
    ->execute();

  // only proceed if query returned data
  if ($result->rowCount()) {
    $questions = $result->fetchAll(PDO::FETCH_ASSOC);
    foreach ($questions as &$quiz_question) {
      $quiz_question['old_qnr_id'] = $quiz_question['qnr_id'];
      $quiz_question['parent_nid'] = $quiz_nid;
      $quiz_question['parent_vid'] = $new_quiz_vid;
      unset($quiz_question['qnr_id']);
      drupal_write_record('quiz_node_relationship', $quiz_question);
    }

    // Update the parentage when a new revision is created.
    // @todo this is copy pasta from quiz_set_questions
    foreach ($questions as $question) {
      db_update('quiz_node_relationship')
        ->condition('qnr_pid', $question['old_qnr_id'])
        ->condition('parent_nid', $quiz_nid)
        ->condition('parent_vid', $new_quiz_vid)
        ->fields(array('qnr_pid' => $question['qnr_id']))
        ->execute();
    }
  }

  /* Update terms if any */
  $result = db_select('quiz_terms', 'qt')
    ->fields('qt', array('nid', 'tid', 'weight', 'max_score', 'number'))
    ->condition('vid', $old_quiz_vid)
    ->execute();
  // only proceed if query returned data
  if ($result->rowCount()) {
    $insert_query = db_insert('quiz_terms')
      ->fields(array('nid', 'vid', 'tid', 'weight', 'max_score', 'number'));
    while ($quiz_term = $result->fetchAssoc()) {
      $insert_query->values(array(
        'nid' => $quiz_nid,
        'vid' => $new_quiz_vid,
        'tid' => $quiz_term['tid'],
        'weight' => $quiz_term['weight'],
        'max_score' => $quiz_term['max_score'],
        'number' => $quiz_term['number'],
      ));
    }
    $insert_query->execute();
  }

  /* $sql = "INSERT INTO {quiz_terms} (nid, vid, tid, weight, max_score, number)
    SELECT qt.nid, %d, qt.tid, qt.weight, qt.max_score, qt.number
    FROM {quiz_terms} qt
    WHERE qt.vid = %d"; */
}

/**
 * Handles quiz taking.
 *
 * This gets executed when the main quiz node is first loaded.
 *
 * @param $quiz
 *   The quiz node.
 *
 * @return
 *   Content array.
 */
function quiz_take_quiz($quiz) {
  global $user;

  // Make sure we use the same revision of the quiz throughout the quiz taking
  // session.
  $result_id = !empty($_SESSION['quiz'][$quiz->nid]['result_id']) ? $_SESSION['quiz'][$quiz->nid]['result_id'] : NULL;
  if ($result_id && $quiz_result = quiz_result_load($result_id)) {
    // Enforce that we have the same quiz version.
    $quiz = node_load($quiz_result->nid, $quiz_result->vid);
  }
  else {
    // User doesn't have attempt in session. If we allow resuming we can load it
    // from the database.
    if ($quiz->allow_resume) {
      if ($result_id = _quiz_active_result_id($user->uid, $quiz->nid, $quiz->vid)) {
        $_SESSION['quiz'][$quiz->nid]['result_id'] = $result_id;
        $_SESSION['quiz'][$quiz->nid]['current'] = 1;
        $quiz_result = quiz_result_load($result_id);
        $quiz = node_load($quiz_result->nid, $quiz_result->vid);
        // Resume a quiz from the database.
        drupal_set_message(t('Resuming a previous quiz in-progress.'), 'status');
      }
    }
  }

  if (!$result_id) {
    // Can user start quiz?
    if (quiz_start_check($quiz)) {
      // Set up a new attempt.
      $quiz_result = _quiz_take_quiz_init($quiz);
      $_SESSION['quiz'][$quiz->nid]['result_id'] = $quiz_result->result_id;
      $_SESSION['quiz'][$quiz->nid]['current'] = 1;

      // Call hook_quiz_begin().
      module_invoke_all('quiz_begin', $quiz, $quiz_result->result_id);
    }
    else {
      return array('body' => array('#markup' => t('This quiz is closed.')));
    }
  }

  if (!quiz_availability($quiz)) {
    return array('body' => array('#markup' => t('This quiz is not available.')));
  }

  drupal_goto("node/{$quiz->nid}/take/" . ($_SESSION['quiz'][$quiz->nid]['current']));
}

/**
 * Take a quiz questions.
 *
 * @param type $quiz
 *   A quiz node.
 * @param type $question_number
 *   A question number, starting at 1. Pages do not have question numbers. Quiz
 *   directions are considered part of the numbering.
 */
function quiz_take_question($quiz, $question_number) {
  if (!empty($_SESSION['quiz'][$quiz->nid]['result_id'])) {
    $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
    $question = $quiz_result->layout[$question_number];

    if (!empty($question['qnr_pid'])) {
      // Find the parent.
      foreach ($quiz_result->layout as $pquestion) {
        if ($pquestion['qnr_id'] == $question['qnr_pid']) {
          // Load the page that the requested question belongs to.
          $question_node = node_load($pquestion['nid']);
        }
      }
    }
    else {
      // Load the question.
      $question_node = node_load($question['nid']);
    }
  }

  if (!$question_node) {
    // Question disappeared or invalid session. Start over.
    unset($_SESSION['quiz'][$quiz->nid]);
    drupal_goto("node/{$quiz->nid}");
  }

  // Mark this as the current question.
  quiz_question_goto($quiz, $question_number);

  // Added the progress info to the view.
  $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
  $questions = array();
  foreach ($quiz_result->layout as $idx => $question) {
    if (!empty($question['number'])) {
      // Question has a number associated with it. Show it in the jumper.
      $questions[$idx] = $question['number'];
    }
  }
  $content['progress']['#markup'] = theme('quiz_progress', array(
    'questions' => $questions,
    'current' => arg(3),
    'allow_jumping' => $quiz->allow_jumping,
    'time_limit' => $quiz->time_limit,
  ));
  $content['progress']['#weight'] = -50;

  /**
   * @todo: wat do?
    if (count($_SESSION['quiz'][$quiz->nid]['quiz_questions']) + count($_SESSION['quiz'][$quiz->nid]['previous_quiz_questions']) > $number_of_questions) {
    drupal_set_message(t('At least one question have been deleted from the quiz after you started taking it. You will have to start over.'), 'warning', FALSE);
    unset($_SESSION['quiz'][$quiz->nid]);
    drupal_goto('node/' . $quiz->nid . '/take');
    }
   */
  if (isset($_SESSION['quiz'][$quiz->nid]['question_duration'])) {
    $time = $_SESSION['quiz'][$quiz->nid]['question_duration'];
    if ($time < 1) {
      // The page was probably submitted by the js, we allow the data to be stored
      $time = 1;
    }
    db_update('quiz_node_results')
      ->fields(array('time_left' => $time))
      ->condition('result_id', $_SESSION['quiz'][$quiz->nid]['result_id'])
      ->execute();

    if ($time <= 1) {
      // Quiz has been timed out, run a loop to mark the remaining questions
      // as skipped.
      // @todo we just need to run quiz_end_score here, I think
      drupal_set_message(t('You have run out of time.'), 'error');
    }
    else {
      // There is still time left, so let's go ahead and insert the countdown
      // javascript.
      if (function_exists('jquery_countdown_add') && variable_get('quiz_has_timer', 1)) {
        jquery_countdown_add('.countdown', array('until' => $time, 'onExpiry' => 'finished', 'compact' => TRUE, 'layout' => t('Time left') . ': {hnn}{sep}{mnn}{sep}{snn}'));
        // These are the two button op values that are accepted for answering
        // questions.
        $button_op1 = drupal_json_encode(t('Finish'));
        $button_op2 = drupal_json_encode(t('Next'));
        $js = "
            function finished() {
              // Find all buttons with a name of 'op'.
              var buttons = jQuery('input[type=submit][name=op], button[type=submit][name=op]');
              // Filter out the ones that don't have the right op value.
              buttons = buttons.filter(function() {
                return this.value == $button_op1 || this.value == $button_op2;
              });
              if (buttons.length == 1) {
                // Since only one button was found, this must be it.
                buttons.click();
              }
              else {
                // Zero, or more than one buttons were found; fall back on a page refresh.
                window.location = window.location.href;
              }
            }
          ";
        drupal_add_js($js, array('type' => 'inline', 'scope' => JS_DEFAULT));
      }
    }
    $_SESSION['quiz'][$quiz->nid]['question_start_time'] = REQUEST_TIME;
  }

  $question_form = drupal_get_form('quiz_question_answering_form', $question_node, $_SESSION['quiz'][arg(1)]['result_id']);
  $content['body']['question']['#markup'] = drupal_render($question_form);
  drupal_set_title($quiz->title);


  return $content;
}

/**
 * Store a quiz question result.
 *
 * @param $quiz
 *  The quiz node
 * @param $result
 *  Object with data about the result for a question.
 * @param $options
 *  Array with options that affect the behavior of this function.
 *  ['set_msg'] - Sets a message if the last question was skipped.
 */
function quiz_store_question_result($quiz, $result, $options) {
  return quiz()->getQuizHelper()->saveQuestionResult($quiz, $result, $options);
}

/**
 * Score a completed quiz.
 */
function quiz_end_scoring($result_id) {
  global $user;
  $quiz_result = quiz_result_load($result_id);
  $quiz = node_load($quiz_result->nid, $quiz_result->vid);
  $questions = $quiz_result->layout;

  // Mark all missing answers as blank. This is essential here for when we may
  // have pages of unanswered questions. Also kills a lot of the skip code that
  // was necessary before.
  foreach ($quiz_result->layout as $qinfo) {
    // Load the Quiz answer submission from the database.
    $qra = quiz_result_answer_load($result_id, $qinfo['nid'], $qinfo['vid']);
    $current_question = node_load($qinfo['nid'], $qinfo['vid']);

    foreach ($questions as $question) {
      if ($question['nid'] == $current_question->nid) {
        $question_array = $question;
      }
    }

    if (!$qra) {
      $qi_instance = _quiz_question_response_get_instance($result_id, $current_question, NULL);
      $qi_instance->delete();
      $qi_instance->saveResult();
      $bare_object = $qi_instance->toBareObject();
      quiz_store_question_result($quiz, $bare_object, array('set_msg' => TRUE, 'question_data' => $question_array));
    }
  }

  $score = quiz_calculate_score($quiz, $result_id);
  if (!isset($score['percentage_score'])) {
    $score['percentage_score'] = 0;
  }
  $quiz_result->is_evaluated = $score['is_evaluated'];
  $quiz_result->score = $score['percentage_score'];
  $quiz_result->time_end = REQUEST_TIME;
  entity_save('quiz_result', $quiz_result);
  if ($user->uid) {
    $score['passing'] = quiz_is_passed($user->uid, $quiz->nid, $quiz->vid);
  }
  else {
    $score['passing'] = $score['percentage_score'] >= $quiz->pass_rate;
  }
  return $score;
}

/**
 * Actions to take at the end of a quiz
 *
 * @param $quiz
 *  The quiz node
 * @param $result_id
 *  Result id
 * @param $score
 *  Score as a number
 */
function quiz_end_actions($quiz, $score, $session_data) {
  // Call hook_quiz_finished().
  // @TODO consider hook_entity_update if we make quiz results rules capable
  module_invoke_all('quiz_finished', $quiz, $score, $session_data);

  // Lets piggy back here to perform the quiz defined action since were done
  // with this quiz.
  // We will verify that there is an associated action with this quiz and then
  // perform that action.
  if (!empty($quiz->aid)) {
    // @TODO get rid of this. Replace with rules. Make quiz results entities or
    // something
    // Some actions are reliant on objects and I am unsure which ones, for now I
    // have simply passed the actions_do() function an empty array. By passing
    // this function a single id then it will retrieve the callback, get the
    // parameters and perform that function (action) for you.
    actions_do($quiz->aid, $quiz, $score, $session_data);
  }

  return $score;
}

/**
 * This functions returns the default email subject and body format which will
 * be used at the end of quiz.
 */
function quiz_email_results_format($type, $target) {
  global $user;
  if ($type == 'subject') {
    if ($target == 'author') {
      return t('!title Results Notice from !sitename');
    }
    if ($target == 'taker') {
      return t('!title Results Notice from !sitename');
    }
  }
  if ($type == 'body') {
    if ($target == 'author') {
      return t('Dear !author') . "\n\n" .
        t('!taker attended the quiz !title on !date') . "\n" .
        t('Test Description : !desc') . "\n" .
        t('!taker got !correct out of !total points in !minutes minutes. Score given in percentage is !percentage') . "\n" .
        t('You can access the result here !url') . "\n";
    }
    if ($target == 'taker') {
      return t('Dear !taker') . "\n\n" .
        t('You attended the quiz !title on !date') . "\n" .
        t('Test Description : !desc') . "\n" .
        t('You got !correct out of !total points in !minutes minutes. Score given in percentage is !percentage') . "\n" .
        t('You can access the result here !url') . "\n";
    }
  }
}

/**
 * Update a score for a quiz.
 *
 * This updates the quiz node results table.
 *
 * It is used in cases where a quiz score is changed after the quiz has been
 * taken. For example, if a long answer question is scored later by a human,
 * then the quiz should be updated when that answer is scored.
 *
 * Important: The value stored in the table is the *percentage* score.
 *
 * @param $quiz
 *   The quiz node for the quiz that is being scored.
 * @param $result_id
 *   The result ID to update.
 * @return
 *   The score as an integer representing percentage. E.g. 55 is 55%.
 */
function quiz_update_total_score($quiz, $result_id) {
  $score = quiz_calculate_score($quiz, $result_id);
  db_update('quiz_node_results')
    ->fields(array(
      'score' => $score['percentage_score'],
    ))
    ->condition('result_id', $result_id)
    ->execute();
  if ($score['is_evaluated']) {
    // Call hook_quiz_scored().
    module_invoke_all('quiz_scored', $quiz, $score, $result_id);
    _quiz_maintain_results($quiz, $result_id);
    db_update('quiz_node_results')
      ->fields(array('is_evaluated' => 1))
      ->condition('result_id', $result_id)
      ->execute();
  }
  return $score['percentage_score'];
}

/**
 * Updates the max_score property on the specified quizzes
 *
 * @param $quizzes_to_update
 *  Array with the vid's of the quizzes to update
 */
function quiz_update_max_score_properties($quizzes_to_update) {
  if (empty($quizzes_to_update)) {
    return;
  }

  db_update('quiz_node_properties')
    ->expression('max_score', 'max_score_for_random * number_of_random_questions + (
      SELECT COALESCE(SUM(max_score), 0)
      FROM {quiz_node_relationship} qnr
      WHERE qnr.question_status = ' . QUESTION_ALWAYS . '
      AND parent_vid = {quiz_node_properties}.vid)')
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  db_update('quiz_node_properties')
    ->expression('max_score', '(SELECT COALESCE(SUM(qt.max_score * qt.number), 0)
      FROM {quiz_terms} qt
      WHERE qt.nid = {quiz_node_properties}.nid AND qt.vid = {quiz_node_properties}.vid)')
    ->condition('randomization', 3)
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  db_update('node_revision')
    ->fields(array('timestamp' => REQUEST_TIME))
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  db_update('node')
    ->fields(array('changed' => REQUEST_TIME))
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  $results_to_update = db_query('SELECT vid FROM {quiz_node_properties} WHERE vid IN (:vid) AND max_score <> :max_score', array(':vid' => $quizzes_to_update, ':max_score' => 0))->fetchCol();
  if (!empty($results_to_update)) {
    db_update('quiz_node_results')
      ->expression('score', 'ROUND(
        100 * (
          SELECT COALESCE (SUM(a.points_awarded), 0)
          FROM {quiz_node_results_answers} a
          WHERE a.result_id = {quiz_node_results}.result_id
        ) / (
          SELECT max_score
          FROM {quiz_node_properties} qnp
          WHERE qnp.vid = {quiz_node_results}.vid
        )
      )')
      ->condition('vid', $results_to_update, 'IN')
      ->execute();
  }
}

/**
 * Check a user/quiz combo to see if the user passed the given quiz.
 *
 * This will return TRUE if the user has passed the quiz at least once, and
 * FALSE otherwise. Note that a FALSE may simply indicate that the user has not
 * taken the quiz.
 *
 * @param $uid
 *   The user ID.
 * @param $nid
 *   The node ID.
 * @param $vid
 *   The version ID.
 */
function quiz_is_passed($uid, $nid, $vid) {
  return quiz()->getQuizHelper()->isPassed($uid, $nid, $vid);
}

/**
 * Actions to take place at the start of a quiz.
 *
 * This is called when the quiz node is viewed for the first time. It ensures
 * that the quiz can be taken at this time.
 *
 * @param $quiz
 *   The quiz node.
 *
 * @return
 *   Return quiz_node_results result_id, or FALSE if there is an error.
 */
function quiz_start_check($quiz) {
  global $user;

  $user_is_admin = user_access('edit any quiz content') || (user_access('edit own quiz content') && $quiz->uid == $user->uid);

  // Make sure this is available.
  if ($quiz->quiz_always != 1) {
    // Compare current GMT time to the open and close dates (which should still
    // be in GMT time).
    $now = REQUEST_TIME;

    if ($now >= $quiz->quiz_close || $now < $quiz->quiz_open) {
      if ($user_is_admin) {
        drupal_set_message(t('You are marked as an administrator or owner for this quiz. While you can take this quiz, the open/close times prohibit other users from taking this quiz.'), 'status');
      }
      else {
        drupal_set_message(t('This @quiz is not currently available.', array('@quiz' => QUIZ_NAME)), 'status');
        // Can't take quiz.
        return FALSE;
      }
    }
  }

  // Check to see if this user is allowed to take the quiz again:
  if ($quiz->takes > 0) {
    $taken = db_query("SELECT COUNT(*) AS takes FROM {quiz_node_results} WHERE uid = :uid AND nid = :nid", array(':uid' => $user->uid, ':nid' => $quiz->nid))->fetchField();
    $allowed_times = format_plural($quiz->takes, '1 time', '@count times');
    $taken_times = format_plural($taken, '1 time', '@count times');

    // The user has already taken this quiz.
    if ($taken) {
      if ($user_is_admin) {

        drupal_set_message(t('You have taken this quiz already. You are marked as an owner or administrator for this quiz, so you can take this quiz as many times as you would like.'), 'status');
      }
      // If the user has already taken this quiz too many times, stop the user.
      elseif ($taken >= $quiz->takes) {
        drupal_set_message(t('You have already taken this quiz @really. You may not take it again.', array('@really' => $taken_times)), 'error');
        return FALSE;
      }
      // If the user has taken the quiz more than once, see if we should report
      // this.
      elseif ($quiz->show_attempt_stats) {
        drupal_set_message(t("You can only take this quiz @allowed. You have taken it @really.", array('@allowed' => $allowed_times, '@really' => $taken_times)), 'status');
      }
    }
  }

  // Check to see if the user is registered, and user alredy passed this quiz.
  if ($quiz->show_passed && $user->uid && quiz_is_passed($user->uid, $quiz->nid, $quiz->vid)) {
    drupal_set_message(t('You have already passed this @quiz.', array('@quiz' => QUIZ_NAME)), 'status');
  }

  return TRUE;
}

/**
 * Find out if a quiz is available for taking or not
 *
 * @param $quiz
 *  The quiz node
 * @return
 *  TRUE if available
 *  Error message(String) if not available
 */
function quiz_availability($quiz) {
  return quiz()->getQuizHelper()->isAvailable($quiz);
}

/**
 * Creates a unique id to be used when storing results for a quiz taker.
 *
 * @param $quiz
 *   The quiz node.
 * @return $result_id
 *   The result id.
 */
function quiz_create_rid($quiz) {
  $result_id = db_insert('quiz_node_results')
    ->fields(array(
      'nid' => $quiz->nid,
      'vid' => $quiz->vid,
      'uid' => $GLOBALS['user']->uid,
      'time_start' => REQUEST_TIME,
    ))
    ->execute();
  if (!is_numeric($result_id)) {
    form_set_error(t('There was a problem starting the @quiz. Please try again later.', array('@quiz' => QUIZ_NAME), array('langcode' => 'error')));
    return FALSE;
  }
  return $result_id;
}

/**
 * Calculates the score user received on quiz.
 *
 * @param $quiz
 *   The quiz node.
 * @param $result_id
 *   Quiz result ID.
 *
 * @return array
 *   Contains three elements: question_count, num_correct and percentage_score.
 */
function quiz_calculate_score($quiz, $result_id) {
  return quiz()->getQuizHelper()->getResultHelper()->calculateScore($quiz, $result_id);
}

/**
 * @param $type
 *
 * @return string
 *   Name of module matching the question type, as given by quiz_question_info()
 *   hook.
 */
function quiz_question_module_for_type($type) {
  $types = _quiz_get_question_types();
  if (!isset($types[$type])) {
    drupal_set_message(t('The module for the questiontype %type is not enabled', array('%type' => $type)), 'warning');
    return FALSE;
  }
  return $types[$type]['module'];
}

/**
 * Retrieves a list of questions (to be taken) for a given quiz.
 *
 * If the quiz has random questions this function only returns a random
 * selection of those questions. This function should be used to decide
 * what questions a quiz taker should answer.
 *
 * This question list is stored in the user's result, and may be different
 * when called multiple times. It should only be used to generate the layout
 * for a quiz attempt and NOT used to do operations on the questions inside of
 * a quiz.
 *
 * @param $quiz
 *   Quiz node.
 * @return
 *   Array of question node IDs.
 */
function quiz_build_question_list($quiz) {
  return quiz()->getQuizHelper()->getQuestionList($quiz);
}

/**
 * Builds the questionlist for quizzes with categorized random questions
 *
 * @see quiz_build_question_list()
 */
function _quiz_build_categorized_question_list($quiz) {
  $terms = _quiz_get_terms($quiz->vid);
  $questions = array();
  $nids = array();
  $question_types = array_keys(_quiz_get_question_types());
  if (empty($question_types)) {
    return array();
  }
  $total_count = 0;
  foreach ($terms as $term) {

    $query = db_select('node', 'n');
    $query->join('taxonomy_index', 'tn', 'n.nid = tn.nid');
    $query->fields('n', array('nid', 'vid'));
    $query->fields('tn', array('tid'));
    $query->condition('n.status', 1, '=');
    $query->condition('n.type', $question_types, 'IN');
    $query->condition('tn.tid', $term->tid, '=');
    if (!empty($nids)) {
      $query->condition('n.nid', $nids, 'NOT IN');
    }
    $query->range(0, $term->number);
    $query->orderBy('RAND()');

    $result = $query->execute();
    $count = 0;
    while ($question = $result->fetchAssoc()) {
      $count++;
      $question['tid'] = $term->tid;
      $question['number'] = $count + $total_count;
      $questions[] = $question;
      $nids[] = $question['nid'];
    }
    $total_count += $count;
    if ($count < $term->number) {
      return array(); // Not enough questions
    }
  }
  return $questions;
}
 * Map node properties to a question object.
 *
 * @param $node
 *  The question node.
 *
 * @return
 *  Question object.
 */
function quiz_node_map($node) {
  $new_question = node_load($node->nid, $node->vid);

  // Append extra fields.
  $new_question->latest_vid = $node->latest_vid;
  $new_question->question_status = isset($node->question_status) ? $node->question_status : QUESTION_NEVER;
  if (isset($node->max_score)) {
    $new_question->max_score = $node->max_score;
  }
  if (isset($node->auto_update_max_score)) {
    $new_question->auto_update_max_score = $node->auto_update_max_score;
  }
  $new_question->weight = $node->weight;
  $new_question->qnr_id = $node->qnr_id;
  $new_question->qnr_pid = $node->qnr_pid;

  return $new_question;
}

/**
 * Sets the questions that are assigned to a quiz.
 *
 * @param $quiz
 *   The quiz(node) to modify.
 * @param $questions
 *   An array of questions.
 * @param $set_new_revision
 *   If TRUE, a new revision will be generated. Note that saving
 *   quiz questions unmodified will still generate a new revision of the quiz if
 *   this is set to TRUE. Why? For a few reasons:
 *   - All of the questions are updated to their latest VID. That is supposed to
 *     be a feature.
 *   - All weights are updated.
 *   - All status flags are updated.
 *
 * @return
 *   Boolean TRUE if update was successful, FALSE otherwise.
 */
function quiz_set_questions(&$quiz, $questions, $set_new_revision = FALSE) {
  return quiz()->getQuizHelper()->setQuestions($quiz, $questions, $set_new_revision);
}

/**
 * @} End of "defgroup quiz_public".
 */

/**
 * Get summary text for a particular score from a set of result options.
 *
 * @param $qnid
 *   The quiz node id.
 * @param $qvid
 *   The quiz node revision id.
 * @param $score
 *   The user's final score.
 *
 * @return
 *   Summary text for the user's score.
 */
function _quiz_pick_result_option($qnid, $qvid, $score) {
  return db_query('SELECT option_summary, option_summary_format FROM {quiz_node_result_options}
      WHERE nid = :nid AND vid = :vid AND :option BETWEEN option_start AND option_end', array(':nid' => $qnid, ':vid' => $qvid, ':option' => $score)
    )->fetch();
}

/**
 * Get an array list of random questions for a quiz.
 *
 * @param $quiz
 *   The quiz node.
 *
 * @return
 *   Array of nid/vid combos for quiz questions.
 */
function _quiz_get_random_questions($quiz) {
  return quiz()->getQuizHelper()->getRandomQuestions($quiz);
}

/**
 * Given a term ID, get all of the question nid/vids that have that ID.
 *
 * @param $tid
 *   Integer term ID.
 *
 * @return
 *   Array of nid/vid combos, like array(array('nid'=>1, 'vid'=>2)).
 */
function _quiz_get_random_taxonomy_question_ids($tid, $num_random) {
  if ($tid == 0) {
    return array();
  }

  // Select random questions by taxonomy.
  $term = taxonomy_term_load($tid);
  $tree = taxonomy_get_tree($term->vid, $term->tid);

  // Flatten the taxonomy tree, and just keep term id's.
  $term_ids[] = $term->tid;
  if (is_array($tree)) {
    foreach ($tree as $term) {
      $term_ids[] = $term->tid;
    }
  }
  $term_ids = implode(',', $term_ids);

  // Get all published questions with one of the allowed term ids.
  // TODO Please convert this statement to the D7 database API syntax.
  $result = db_query_range("SELECT n.nid, n.vid
    FROM {node} n
    INNER JOIN {taxonomy_index} tn USING (nid)
    WHERE n.status = 1 AND tn.tid IN ($term_ids)
    AND n.type IN ('" . implode("','", array_keys(_quiz_get_question_types()))
    . "') ORDER BY RAND()");

  $questions = array();
  while ($question_node = db_fetch_array($result)) {
    $question_node['random'] = TRUE;
    $questions[] = $question_node;
  }

  return $questions;
}




/**
 * Retrieve list of published questions assigned to quiz.
 *
 * This function should be used for question browsers and similiar... It should not be used to decide what questions
 * a user should answer when taking a quiz. quiz_build_question_list is written for that purpose.
 *
 * @param $quiz_nid
 *   Quiz node id.
 * @param $quiz_vid
 *   Quiz node version id.
 *
 * @return
 *   An array of questions.
 */
function quiz_get_questions($quiz_nid, $quiz_vid = NULL) {
  return quiz()->getQuizHelper()->getQuestions($quiz_nid, $quiz_vid);
}

/**
 * Get sub-questions.
 */
function quiz_get_sub_questions($qnr_pid, &$questions) {
  return quiz()->getQuizHelper()->getSubQuestions($qnr_pid, $questions);
}


 * This function was copied from the triggers module as to prevent having to be
 * dependent on that module for the actions to work.  The trigger function is
 * called trigger_options().
 *
 * @param $type
 *   One of 'node', 'user', 'comment'.
 *
 * @return
 *   Array keyed by action ID.
 */
function quiz_action_options($type = 'all') {
  $options = array(t('Choose an action'));
  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {
    $options[$action['type']][$aid] = $action['label'];
  }

  if ($type == 'all') {
    return $options;
  }
  else {
    $options[$type][0] = t('Choose an action');
    // Lets sort it to get the choose an action back first.
    ksort($options[$type]);
    return $options[$type];
  }
}

/**
 * Returns an array with quiz titles keyed with quiz node ids.
 *
 * @return array
 *   Options suitable for a form, in which the value is nid.
 */
function quiz_get_quiz_options() {
  return quiz()->getQuizHelper()->getSettingHelper()->getQuizOptions();
}

/**
 * Tells whether a question node is being viewed inside/outside of quiz.
 *
 * @return
 *   Boolean.
 */
function _quiz_is_taking_context() {
  return arg(2) == 'take';
}

/**
 * Retrieves the quiz node from the menu router.
 *
 * @return
 *   Quiz node, if found, or FALSE if quiz node can't be retrieved from the menu
 *   router.
 */
function quiz_get_quiz_from_menu() {
  if ($to_return = menu_get_object('quiz_type_access', 4)) {
    return $to_return;
  }

  //TODO: FIX it. This seems to return NULL in feedback page.
  $node = menu_get_object();
  return (is_object($node) && $node->type == 'quiz') ? $node : FALSE;
}

/**
 * Finds out if a quiz has been answered or not.
 *
 * @return
 *   TRUE if there exists answers to the current question.
 */
function quiz_has_been_answered($node) {
  return quiz()->getQuizHelper()->isAnswered($node);
}

 * Checks if the user has access to save score for his quiz.
 */
function quiz_allow_score_access($quiz, $account = NULL) {
  global $user;
  if ($account == NULL) {
    $account = $user;
  }
  $access = user_access('score any quiz') || (user_access('score own quiz') && $quiz->uid && $account->uid);
  return $access;
}

/**
 * Copies questions when a quiz is translated.
 *
 * @param $node
 *   The new translated quiz node.
 */
function quiz_copy_questions($node) {
  return quiz()->getQuizHelper()->copyQuestions($node);
}

/**
 * Deletes results for a quiz according to the keep results setting
 *
 * @param $quiz
 *  The quiz node to be maintained
 * @param $result_id
 *  The result id of the latest result for the current user
 * @return
 *  TRUE if results where deleted.
 */
function _quiz_maintain_results($quiz, $result_id) {
  global $user;
  return quiz()->getQuizHelper()->getResultHelper()->maintainResult($user, $quiz, $result_id);
}

/**
 * Delete quiz results.
 *
 * @param $result_ids
 *   Result ids for the results to be deleted.
 */
function quiz_delete_results($result_ids) {
  return quiz()->getQuizHelper()->getResultHelper()->deleteByIds($result_ids);
}

/**
 * Returns the users default settings.
 *
 * @param $node
 *   Quiz node.
 * @param $uid
 *   (optional) The uid of the user to get the settings for. Defaults to the
 *   current user (NULL).
 *
 * @return
 *   An array of settings. The array is empty in case no settings are available.
 */
function quiz_get_defaults() {
  return quiz()->getQuizHelper()->getSettingHelper()->getUserDefaultSettings();
}


/**
 * Shortcut to entity_load_single().
 */
function quiz_result_load($result_id) {
  return entity_load_single('quiz_result', $result_id);
}

/**
 * Meun check to see if user has access to take this question.
 */
function quiz_take_question_access($quiz, $question_number) {
  if (!$question_number) {
    return FALSE;
  }

  if ($quiz->allow_jumping) {
    // Access to go to any question. Yay.
    return TRUE;
  }

  $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
  $quiz_result = quiz_result_load($result_id);
  $question_index = $question_number;
  $qinfo_last = $question_number == 1 ? NULL : $quiz_result->layout[$question_index - 1];
  $qinfo = $quiz_result->layout[$question_index];

  if (!$quiz->backwards_navigation) {
    // No backwards navigation.
    if ($qra = quiz_result_answer_load($result_id, $qinfo['nid'], $qinfo['vid'])) {
      // Already have an answer for the requested question.
      return FALSE;
    }
  }

  // Enforce normal navigation.
  if ($question_number == 1 || $qra = quiz_result_answer_load($result_id, $qinfo_last['nid'], $qinfo_last['vid'])) {
    //  Previous answer was submitted or this is the first question.
    return TRUE;
  }
}

/**
 * Show feedback for a question response.
 */
function quiz_take_question_feedback($quiz, $question_number) {
  if (empty($_SESSION['quiz'][$quiz->nid]['result_id'])) {
    $result_id = $_SESSION['quiz']['temp']['result_id'];
  }
  else {
    $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
  }
  $quiz_result = quiz_result_load($result_id);
  $question_node = node_load($quiz_result->layout[$question_number]['nid']);
  $feedback = quiz_question_feedback(node_load(arg(1)), $question_node);
  return $feedback;
}

/**
 * Submit handler to go to the next question from the question feedback.
 */
function quiz_take_question_feedback_submit($form, &$form_state) {
  $quiz = node_load(arg(1));
  $form_state['redirect'] = "node/{$quiz->nid}/take/" . $_SESSION['quiz'][$quiz->nid]['current'];
}

/**
 * Submit handler to go to the quiz results from the last question's feedback.
 */
function quiz_take_question_feedback_end_submit($form, &$form_state) {
  $quiz = node_load(arg(1));
  $result_id = $_SESSION['quiz']['temp']['result_id'];
  $form_state['redirect'] = "node/{$quiz->nid}/quiz-results/$result_id/view";
}

function quiz_jumper($form, $form_state, $questions, $current) {
  $form['question_number'] = array(
    '#type' => 'select',
    '#options' => $questions,
    '#default_value' => $current,
    '#prefix' => t('Question'),
    '#suffix' => t('of @num', array('@num' => count($questions))),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Jump'),
    '#attributes' => array('class' => array('js-hide')),
  );
  return $form;
}

function quiz_jumper_submit($form, &$form_state) {
  $quiz = node_load(arg(1));
  quiz_question_goto($quiz, $form_state['values']['question_number'] - 1);
  $form_state['redirect'] = "node/{$quiz->nid}/take/" . $form_state['values']['question_number'];
}

/**
 * Menu access check for question feedback.
 */
function quiz_question_feedback_access($quiz, $question_number) {
  return quiz()->getQuizHelper()->getFeedbackHelper()->canAccess($quiz, $question_number);
}

/**
 * Load a specific result answer.
 */
function quiz_result_answer_load($result_id, $nid, $vid) {
  return quiz()->getQuizHelper()->getResultHelper()->loadAnswerResult($result_id, $nid, $vid);
}

/**
 * Action to add questions to the current quiz.
 */
function quiz_add_question_to_quiz($question) {
  $quiz = node_load(arg(1));
  return quiz()->getQuizHelper()->addQuestion($quiz, $question);
}
 * Workaround for menu_translate bug.
 */
function question_number_to_arg() {
  return 0;
}

/**
 * Can the quiz taker view the requested review?
 *
 * There's a workaround in here: @kludge
 *
 * When review for the question is enabled, and it is the last question,
 * technically it is the end of the quiz, and the "end of quiz" review settings
 * apply. So we check to make sure that we are in question taking and the
 * feedback is viewed within 5 seconds of completing the question/quiz.
 */
function quiz_feedback_can_review($option, $quiz_result) {
  return quiz()->getQuizHelper()->getFeedbackHelper()->canReview($option, $quiz_result);
}

/**
 * Get the feedback options for Quizzes.
 */
function quiz_get_feedback_options() {
  return quiz()->getQuizHelper()->getFeedbackHelper()->getOptions();
}
