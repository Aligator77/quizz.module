<?php

use Drupal\quiz\Quiz;

/**
 * @file
 * Quiz Module
 *
 * This module allows the creation of interactive quizzes for site visitors.
 *
 * Where possible, user pages are located in quiz.pages.inc, and admin pages
 * are in quiz.admin.inc. Most utility functions have been left here, even if they
 * are only used by a function in one of the other files. quiz_datetime.inc holds
 * some additional date/time functions.
 *
 * Themes are in quiz.pages.inc unless they clearly only apply to admin screens.
 * Then they are in quiz.admin.inc.
 *
 * Views support is included in includes/views/quiz.views.inc
 */
define('QUIZ_VIEWS_DIR', drupal_get_path('module', 'quiz') . '/includes/views');

/**
 * Include hook implementations.
 */
require_once dirname(__FILE__) . '/quiz.hooks.inc';
require_once dirname(__FILE__) . '/quiz.take.inc';

/*
 * Define question statuses...
 */
define('QUESTION_RANDOM', 0);
define('QUESTION_ALWAYS', 1);
define('QUESTION_NEVER', 2);

/**
 * Quiz name.
 */
define('QUIZ_NAME', _quiz_get_quiz_name());

/**
 * Define options for keeping results.
 */
define('QUIZ_KEEP_BEST', 0);
define('QUIZ_KEEP_LATEST', 1);
define('QUIZ_KEEP_ALL', 2);

/**
 * Factory to create quiz helpers wrapper.
 *
 * @staticvar Quiz $quiz
 * @param string $className
 * @return \Drupal\quiz\Quiz
 */
function quiz($className = 'Drupal\quiz\Quiz') {
  static $quiz;
  return null === $quiz ? ($quiz = new $className) : $quiz;
}

/**
 * Helper function to check if the user has any of a given list of permissions.
 *
 * @param args
 *   Any number of permissions.
 * @return
 *   TRUE if the user has access to any of the arguments given.
 */
function quiz_access_multi_or() {
  foreach (func_get_args() as $perm) {
    if (user_access($perm)) {
      return TRUE;
    }
  }
}

/**
 * Result_id, menu argument loader.
 */
function quiz_rid_load($result_id) {
  if ($result_id > 0) {
    return $result_id;
  }
  return FALSE;
}

/**
 * Workaround for a _menu_translate() bug.
 */
function quiz_rid_to_arg() {
  return 0;
}

/**
 * Menu loader callback. Load a quiz node if the given node ID is a quiz.
 */
function quiz_menu_load($nid) {
  if (!is_numeric($nid) || (!$node = node_load($nid))) {
    return FALSE;
  }
  return (!isset($node->type) || $node->type !== 'quiz') ? false : $node;
}

/**
 * Validate that a node is of type quiz, and that the user has access to it.
 *
 * @param $node
 * @param $op
 * @return unknown_type
 */
function quiz_type_confirm($node, $op = NULL) {
  if ($node->type !== 'quiz') {
    return FALSE;
  }
  if (isset($op)) {
    $node_ops = array('view', 'update', 'delete', 'create');
    if (in_array($op, $node_ops)) {
      return node_access($op, $node);
    }
    return user_access($op);
  }
  return user_access('access quiz');
}

/**
 * This function was copied from the triggers module as to prevent having to be
 * dependent on that module for the actions to work.  The trigger function is
 * called trigger_options().
 *
 * @param $type
 *   One of 'node', 'user', 'comment'.
 *
 * @return
 *   Array keyed by action ID.
 */
function quiz_action_options($type = 'all') {
  $options = array(t('Choose an action'));
  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {
    $options[$action['type']][$aid] = $action['label'];
  }

  if ($type == 'all') {
    return $options;
  }
  else {
    $options[$type][0] = t('Choose an action');
    // Lets sort it to get the choose an action back first.
    ksort($options[$type]);
    return $options[$type];
  }
}

/**
 * Helper function to determine if a user has access to the different results
 * pages.
 *
 * @param $quiz
 *   The quiz node.
 * @param $result_id
 *   The result id of a result we are trying to access.
 * @return boolean
 *   TRUE if user has permission.
 */
function quiz_access_results($quiz, $result_id = NULL) {
  global $user;
  return quiz()->getQuizHelper()->getAccessHelper()->canAccessResults($user, $quiz, $result_id);
}

/**
 * Helper function to determine if a user has access to view his quiz results
 *
 * @param object $quiz
 *  The Quiz node
 */
function quiz_access_my_results($quiz) {
  global $user;
  return quiz()->getQuizHelper()->getAccessHelper()->canAccessMyResults($quiz, $user);
}

/**
 * Helper function to determine if a user has access to view a specific quiz result.
 *
 * @param int|stdClass $result
 *  Result id
 * @return boolean
 *  True if access, false otherwise
 */
function quiz_access_my_result($result) {
  $result_id = is_object($result) ? $result->result_id : $result;
  return quiz()->getQuizHelper()->getResultHelper()->isResultCompleted($result_id);
}

/**
 * Find out if a quiz is available for taking or not
 *
 * @param $quiz
 *  The quiz node
 * @return
 *  TRUE if available
 *  Error message(String) if not available
 */
function quiz_availability($quiz) {
  return quiz()->getQuizHelper()->isAvailable($quiz);
}

/**
 * Retrieves a list of questions (to be taken) for a given quiz.
 *
 * If the quiz has random questions this function only returns a random
 * selection of those questions. This function should be used to decide
 * what questions a quiz taker should answer.
 *
 * This question list is stored in the user's result, and may be different
 * when called multiple times. It should only be used to generate the layout
 * for a quiz attempt and NOT used to do operations on the questions inside of
 * a quiz.
 *
 * @param $quiz
 *   Quiz node.
 * @return
 *   Array of question node IDs.
 */
function quiz_build_question_list($quiz) {
  return quiz()->getQuizHelper()->getQuestionList($quiz);
}

/**
 * Returns an array with quiz titles keyed with quiz node ids.
 *
 * @return array
 *   Options suitable for a form, in which the value is nid.
 */
function quiz_get_quiz_options() {
  return quiz()->getQuizHelper()->getSettingHelper()->getQuizOptions();
}

/**
 * Finds out if a quiz has been answered or not.
 *
 * @return
 *   TRUE if there exists answers to the current question.
 */
function quiz_has_been_answered($quiz) {
  return quiz()->getQuizHelper()->isAnswered($quiz);
}

/**
 * Menu access check for question feedback.
 */
function quiz_question_feedback_access($quiz, $question_number) {
  return quiz()->getQuizHelper()->getFeedbackHelper()->canAccess($quiz, $question_number);
}

/**
 * Load a specific result answer.
 */
function quiz_result_answer_load($result_id, $nid, $vid) {
  return quiz()->getQuizHelper()->getResultHelper()->loadAnswerResult($result_id, $nid, $vid);
}

/**
 * Action to add questions to the current quiz.
 */
function quiz_add_question_to_quiz($question) {
  $quiz = node_load(arg(1)); // @TODO: Is this correct? We can load quiz from question thou!
  return quiz()->getQuizHelper()->addQuestion($quiz, $question);
}

/**
 * Can the quiz taker view the requested review?
 *
 * There's a workaround in here: @kludge
 *
 * When review for the question is enabled, and it is the last question,
 * technically it is the end of the quiz, and the "end of quiz" review settings
 * apply. So we check to make sure that we are in question taking and the
 * feedback is viewed within 5 seconds of completing the question/quiz.
 */
function quiz_feedback_can_review($option, $quiz_result) {
  return quiz()->getQuizHelper()->getFeedbackHelper()->canReview($option, $quiz_result);
}

/**
 * Updates the max_score property on the specified quizzes
 *
 * @param $vids
 *  Array with the vid's of the quizzes to update
 */
function quiz_update_max_score_properties($vids) {
  return quiz()->getQuizHelper()->updateMaxScoreProperties($vids);
}

/**
 * @param string $question_type
 *
 * @return string
 *   Name of module matching the question type, as given by quiz_question_info()
 *   hook.
 */
function quiz_question_module_for_type($question_type) {
  return quiz()->getQuizHelper()->getQuestionModuleFromType($question_type);
}

/**
 * Checks if the user has access to save score for his quiz.
 */
function quiz_allow_score_access($quiz, $account = NULL) {
  global $user;

  if ($account == NULL) {
    $account = $user;
  }

  return quiz()->getQuizHelper()->getAccessHelper()->canAccessScore($quiz, $account);
}

// ---------------------
//  Internal functions
// ---------------------

/**
 * Get data for all terms belonging to a Quiz with categorized random questions
 *
 * @param int $vid
 *  version id for the quiz
 * @return array
 *  Array with all terms that belongs to the quiz as objects
 */
function _quiz_get_terms($vid) {
  $sql = 'SELECT td.name, qt.*
    FROM {quiz_terms} qt
    JOIN {taxonomy_term_data} td ON qt.tid = td.tid
    WHERE qt.vid = :vid
    ORDER BY qt.weight';
  return db_query($sql, array(':vid' => $vid))->fetchAll();
}

/**
 * If a quiz is saved with random categories we should make sure all questions
 * are removed from the quiz
 *
 * @param $node
 *   Quiz node.
 */
function _quiz_check_num_always(&$node) {
  if ($node->randomization != 3) {
    return;
  }
  db_delete('quiz_node_relationship')
    ->condition('parent_vid', $node->vid)
    ->execute();
}

/**
 * If a quiz is saved as not randomized we should make sure all random questions
 * are converted to always.
 *
 * @param $node
 *   Quiz node.
 */
function _quiz_check_num_random(&$node) {
  if ($node->randomization == 2) {
    return;
  }
  db_delete('quiz_node_relationship')
    ->condition('question_status', QUESTION_RANDOM)
    ->condition('parent_vid', $node->vid)
    ->execute();
}

/**
 * Get the number of compulsory questions for a quiz.
 *
 * @param $nid
 *   Quiz node id.
 * @param $vid
 *   Quiz node version id.
 * @return
 *   Number of compulsory questions.
 */
function _quiz_get_num_always_questions($vid) {
  return db_query('SELECT COUNT(*) FROM {quiz_node_relationship} qnr
          JOIN {node} n ON n.nid = qnr.child_nid
          WHERE n.status=1 AND qnr.parent_vid = :parent_vid AND qnr.question_status = :question_status', array(':parent_vid' => $vid, ':question_status' => QUESTION_ALWAYS))->fetchField();
}

/**
 * Modifies the format fieldset.
 *
 * Adds a class to all the format fieldsets and removes unwanted strings.
 * A javascript is added by the forms theme function to make sure all format
 * selectors follows the body field format selector.
 * Used when there are multiple format selectors on one page.
 *
 * Could be a deprecated function in d7
 *
 * @param $format
 *   The format fieldset.
 */
function _quiz_format_mod(&$format) {
  $format['#attributes']['class'] = array('quiz-filter');
  if (isset($format['format'])) {
    $format['format']['guidelines']['#value'] = ' ';
    foreach (array_keys($format) as $key) {
      if (is_numeric($key)) {
        $format[$key]['#value'] = ' ';
      }
    }
  }
}

/**
 * Helper function used when validating integers.
 *
 * @param $value
 *   The value to be validated.
 * @param $min
 *   The minimum value $value is allowed to be.
 * @param $max
 *   The maximum value $value is allowed to be.
 *
 * @return
 *   TRUE if integer in the allowed range. FALSE otherwise.
 */
function _quiz_is_int($value, $min = 1, $max = NULL) {
  $to_return = ((string) $value === (string) (int) $value);

  // $value is not an integer.
  if (!$to_return) {
    return FALSE;
  }

  // $value is too small.
  if ($value < $min) {
    return FALSE;
  }

  // $value is too big.
  if (isset($max) && $value > $max) {
    return FALSE;
  }

  // $value is an integer in the allowed range.
  return TRUE;
}

/**
 * Retrieve list of question types.
 *
 * @return
 *  Array of question types.
 */
function _quiz_get_question_types() {
  static $to_return = array();

  // We vastly improves performance by statically caching the question types.
  if (!empty($to_return)) {
    return $to_return;
  }

  // Get question types from the modules that defines them..
  $quiz_questions = module_invoke_all('quiz_question_info');
  if (empty($quiz_questions)) {
    drupal_set_message(t('You need to install and enable at least one question type(multichoice for instance) to use quiz.'), 'warning', FALSE);
    return array();
  }

  return $quiz_questions;
}

/**
 * Retrieve list of vocabularies for all quiz question types.
 *
 * @return
 *   An array containing a vocabulary list.
 */
function _quiz_get_vocabularies() {
  $vocabularies = array();
  $types = array_keys(_quiz_get_question_types());
  foreach ($types as $type) {
    foreach (taxonomy_get_vocabularies($type) as $vid => $vocabulary) {
      $vocabularies[$vid] = $vocabulary;
    }
  }
  return $vocabularies;
}

/**
 * Given a term ID, get all of the question nid/vids that have that ID.
 *
 * @param $tid
 *   Integer term ID.
 *
 * @return
 *   Array of nid/vid combos, like array(array('nid'=>1, 'vid'=>2)).
 */
function _quiz_get_random_taxonomy_question_ids($tid, $num_random) {
  if ($tid == 0) {
    return array();
  }

  // Select random questions by taxonomy.
  $term = taxonomy_term_load($tid);
  $tree = taxonomy_get_tree($term->vid, $term->tid);

  // Flatten the taxonomy tree, and just keep term id's.
  $term_ids[] = $term->tid;
  if (is_array($tree)) {
    foreach ($tree as $term) {
      $term_ids[] = $term->tid;
    }
  }
  $term_ids = implode(',', $term_ids);

  // Get all published questions with one of the allowed term ids.
  // TODO Please convert this statement to the D7 database API syntax.
  $result = db_query_range("SELECT n.nid, n.vid
    FROM {node} n
    INNER JOIN {taxonomy_index} tn USING (nid)
    WHERE n.status = 1 AND tn.tid IN ($term_ids)
    AND n.type IN ('" . implode("','", array_keys(_quiz_get_question_types()))
    . "') ORDER BY RAND()");

  $questions = array();
  while ($question_node = db_fetch_array($result)) {
    $question_node['random'] = TRUE;
    $questions[] = $question_node;
  }

  return $questions;
}

/**
 * Returns the users default settings.
 *
 * @param $node
 *   Quiz node.
 * @param $uid
 *   (optional) The uid of the user to get the settings for. Defaults to the
 *   current user (NULL).
 *
 * @return
 *   An array of settings. The array is empty in case no settings are available.
 *
 * @see https://www.drupal.org/node/2353181
 */
function _quiz_load_user_settings($uid = NULL) {
  // The def_uid property is the default user id. It is used if there are no
  // settings store for the current user.
  $uid = isset($uid) ? $uid : $GLOBALS['user']->uid;

  $query = db_select('quiz_user_settings', 'qus')
    ->fields('qus')
    ->condition('uid', $uid);
  $res = $query->execute()->fetchAssoc();
  if (!empty($res)) {
    foreach ($res as $key => $value) {
      if (!in_array($key, array('nid', 'vid', 'uid'))) {
        $settings[$key] = $value;
      }
    }
    $settings['resultoptions'][] = db_select('quiz_node_result_options', 'qnro')
      ->fields('qnro')
      ->condition('nid', $res['nid'])
      ->condition('vid', $res['vid'])
      ->execute()
      ->fetchAll();
    return $settings;
  }
  return array();
}

/**
 * Get the quiz name variable and set it as a constant so we don't have to keep
 * calling it in every function.
 *
 * @return
 *   Quiz name variable.
 */
function _quiz_get_quiz_name() {
  // @todo: remove all the quiz_name stuff? Isn't there better ways to do this?
  return variable_get('quiz_name', 'Quiz');
}
